Бэкэнд аллокатор - Freelist

По смещению 0x178 в структуре кучи находится массив Freelist[]. Он содержит двусвязный список чанков. Двусвязность достигается засчёт указателей flink и blink.

Диаграмма выше показывает, что freelist содержит чанки от 0 до 128. Любой размер чанка между 0 и 1016 байтам (максимальный размер равен 1024, минис 8 байт на метаданные) занимает [размер] * 8 байт. К примеру, у меня есть чанк размером 40 байт. Тогда он будет иметь в массиве индекс 4 (40 / 8).

Если размер превышает 1016 (127 * 8) байта, тогда он будется храниться во freelist[0] в порядке возрастания. Ни представлено описание чанка во freelist.

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

Microsoft добавила некоторые ограничения, чтобы защититься от unlink-атак в структурах freelist. Ниже представлен их короткий список.

Безопасный разрыв связи во freelist:
Этот механизм был реализован в XP SP2 и выше. В сущности эта техника не позволяет провести атаку, описанную в первой части "Переполнения буфера кучи для людей". Она проверяет, что flink предыдущего чанка указавает на текущий аллоцированный чанк, как и blink следующего чанка. Ниже описание и демонстрация механизма.

№№№№№№№№№№№№№№№№№№№№№№№№№№
№№№№№№№№№№№№№№№№№№№№№№№№№№
№№№№№№№№№№№№№№№№№№№№№№№№№№

Механизм проверяет указатели, помеченные красными линиями

№№№№№№№№№№№№№№№№№№№№№№№№№№
№№№№№№№№№№№№№№№№№№№№№№№№№№
№№№№№№№№№№№№№№№№№№№№№№№№№№

Если какая-либо из проверок не проходит, производится прыжок по адресу 0x7c936934 в ntdll.dll. Как можете заметить, это почти то же самое, что мы делали при обычном разрыве связи, за исключением того, что теперь проверяется flink/blink.

Freelist header cookies:
Также в SP2 появился механизм, добавляющий в заголовок чанка по смещеню 0x5 рандомный куки. Толко чанки в freelist проверяются на них. Ниже показан чанк с подвеченной кукой. Это рандомный байт, поэтому имеет всего 256 возможных значений. Помните, что в многозадачной среде вы можете его просто перебрать брутфорсом.

Фронтэнд аллокатор - Lookaside

Список lookaside является односвязным и хранит чанки размером до 1016 байт (max: 1024-8). Он нужен для ускорения поиска. Оно достигается, когда приложение использует множество вызовов HeapAlloc() и HeapFree() во время выполнения. Поскольку он должен быть быстрым, в одном его элементе может хранить не больше 3 свободных чанков. Если при вызове HeapFree() в списке уже есть 3 элемента с таким размером, то освобождаемый чанк добавляется во freelist[n].

Размер чанка кучи всегда рассчитывается как размер аллокации + дополнительные 8 байт на заголовок. Тогда при запросе 16 байт в списке lookaside будет искаться 24-байтный чанк (16 + заголовок). В случае, описанном диаграмой ниже, менеджер кучи найдет такой чанк во втором элементе списка.

lookaside хранит только указатель на следующий чанк данных flink.

№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№
№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№
№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№

Когда менеджеру кучи приходит запрос на аллокацию, он ищет удовлетворяющие ему свободные чанки. Для ускорения и оптимизации менеджер сперва пройдётся по списку lookaside. Если там его не найдётся, будет использован бэкэнд аллокатор. В этом случае будет произведён проход по списку freelist, начиная с freelist[1] до freelist[127]. Если свободный чанк не найдётся, будет просмотрел элемент freelist[0] в попытке найти чанк с большим размером, который потом будет разделён. Нужная часть будет возвращена менеджеру, а остатки отправятся во freelist[n] (n определяется по количествую оставшихся байтов). Это ведёт нас к следующей части, операциям кучи.

Базовые операции кучи

Разделение чанка:
Просесс получения из freelist[n] большого чанка, который разбивается на маленькие. Если полученный чанк больше запрошенного размера, чанк разбивается так, чтобы удовлетворить запрос.

Предположим во freelist[0] лежит всего один чанк размером 2048 айт. Если запрашивается выделение 1024 байт (с учётом заголовка), тогда этот чанк делится, один кусок в 1024 байта отправлятеся назад во freelist[0], а другой возвращается.

Слияние кучи:
Процесс объединение в один трёх соседних свободных чанков. Происходит при освобождении среднего из них, два боковых должны быть уже свободными.

Причина, по которой это делается заключается в эффективном использовании сегемента памяти. Разумеется, освобождение чанков не всегда эффективно. Слияние кучи является очень важной операций, поскольку при этом несколько свободных чанков объединяются в один, который может быть позже использован для аллокации бОльшего размера позднее. Если этого не делать, сегмент будет заполнятся неиспользуемыми чанками, а также будет всё более фрагментирован.