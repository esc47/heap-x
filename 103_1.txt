Переполнение буфера кучи. Часть 3

Привет, ребята. Некоторое время назад я рассказывал о древней, но важной технике переполнения буфера кучи в Windows XP SP3. Сегодня я расскажу о еще одной. Вдобавок я познакомлю вас с моим плагином для Immunity Debugger под названием !heaper.

В первую очередь как человек, понимающий технические сложности и тонкости, связанные с этой темой, хочу поблагодарить всех исследователей безопасности за ту работу, которую они провели до меня. Если бы не эти люди, этой серии статей не было бы.

Поэтому ОГРОМНОЕ спасибо Бретту Муру (Brett Moore), Николасу Вайсману (Nicolas Waisman) и Крису Валасик (Chris Valasek). Ваша работа за гранью исключительного.

Ну что ж, начнём?

В декабре 2005 Бретт Мур опубликовал очень интересное исследование: "Эксплуатация freelist[0] в XP SP2". В частности были рассмотрены два полезных метода, с помощью которых можно атаковать freelist[0]. Мы рассмотрим только одну из них - вставку во freelist[0], в связи с её практичностью.

Вам потребуется:

- Windows XP с установленным SP2/SP3
- Immunity Debugger
- pyparser
- graphviz
- heaper.py - плагин к immunity debugger
- Компилятор C/C++ (Dev C++, lcc-32, MS visual C++ 6.0 (если вы сможете его достать)).
- Удобный для вас скриптовый язык (Я использую python, вы можете пользоваться perl)
- Мозги (и/или настойчивость)
- Некоторые знания Ассемблера, C. Также умение использовать плагин HideDbg для Olly или !hidedebug в Immunity debugger
- Время.

Вставка в freelist[0]
[Идея этой атаки заключается в перезаписи указателя blink в чанке freelist[0]. При вставке чанка перед перезаписанным blink не проверяется перед обновлением указателей flink/blink. Проверка на разрыв связи списка происходит только в манипулируемых чанках и его соседях, но не в тех, связи которых изменяются.]

Чтобы исправить эту проблему в Windows 7 программисты Microsoft добавили проверку, похожую на этот сниппет псевдокода:


Если ссылки на соседей в чанке до, и в чанке после проверены, разумеется это решает проблему и не позволяет атакующему устанавливать произвольный указатель или присваивать произвольное значение, указывающее на неконтролируемый адрес. Ниже грубый пример, с которым мы будем работать:

Несмотря на то что этот код, разумеется, не является примером из реального мира, его задача продемонстрировать технику, которая, будучи усвоенной, может быть использована позже с какой-либо программой.

Скомпилируйте его или скачайте готовый бинарник (b33f: бинарника нет). Открыв его в отладчике, вы увидите:


Спускайтесь ниже, пока не увидите вызовы API из main: HeapCreate, HeapAlloc, HeapFree. Установите точку останова на втором HeapFree и следующих за ним HeapAlloc'ах.


Теперь нужно скрыть факт того, что программа запущена под отладчиком, используем команду '!hidedebug all_debug', чтобы пропатчить все API вызовы.


