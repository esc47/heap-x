Методы обхода механизмов защиты Windows XP SP2/3

Перезапись чанка в lookaside
Этот самый распространённый метод обхода кук и безопасного разрыва связи в списке. Несмотря на то, что его успешность зависит от приложения, в котором она используется, некоторые из них позволяют изучить структуру кучи, чтобы быть уверенным в надёжности эксплуатации. Посколько в lookasode не производятся проверка на разрыв связи или проверка кук, атакующий может переписать указатель flink в соседнем элементе и вернуть его через HeapAlloc() или HeapFree(), чтобы позже записать вредоносный код в следующий доступный чанк.

Давайте посмотрим, как это работает. Глубокий вдох...

1. Начинаем с аллокации чанка A в текущем сегменте.

№№№№№№№№№№№№№№№№№№№№№№№№

2. Аллоцируем еще один чанк B там же.

3. Теперь освобождаем чанк B, он отправляется в список lookaside. С этого момента у нас есть два чанка: один в сегменте, другой в lookaside.

4. Переполняем чанк А (впоследствии его содержимое попадёт в B, обновив flink). Это метаданные, которые будут перезаписаны.

5. Аллоцируем чанк B снова (просим чанк такого же размера, как в шаге 2). Нам вернётся указатель на B, а менеджер кучи обновит данные сегмента для подготовки к следующей аллокации. В flink чанка B теперь указывает на произвольный адрес, который контролируется атакующим.

6. Наконец, получаем управление, аллоцируя чанк C. Он будет слудующим доступным после B, а значит будет указывать туда же, куда указывает flink чанка B. Теперь атакующий записывает в C шеллкод.


По окончанию этого процесса у нас будет контроль над указателем на функцию, которая в идеале будет вызвана после нашей "перезаписи четвёрки". Ниже приведён C код для демонстрации.

Задачей нескольких ассемблерных вставок  __asm__("int $0x3"); заключается в остановке выполнения программы по брекпойту в отладчике. Точно так же вы можете открыть бинарник в отладчике и вручную их установить на каждом вызове. После запуска, мы остановимся на первом брекпойнте. Давайте посмотрим

№№№№№№№№№№№

Мы видим два аллоцированных чанка в сегменте 0x00480000 размером 0x18 байт. Если отнять из этого числа 0x8, получим 0x10 то есть 16 байт. Взглянем на содержимое lookaside, чтобы проверить, поместился ли в него B при освобождении.


Превосходно! Чанк помещён в lookaside (на 8 байт меньше, потому что указывает на заголовок). Этот чанк поместился сюда, потому что его размер меньше 1016 и в lookaside находится меньше 3 чанков такого же размера.

Для уверенность заглянем во freelist

#################

Хорошо, всё выглядит нормально. Внутри нет элементов, за исключением нескольких во freelist[0], но они появляются при создании сегмента и паре других аллокаций. Двигаясь дальше, мы переполняем чанк A строкой из байтов 0x41 до заголовка соседнего чанка. Используя ту же строчку, перепишем в нём flink байтами 0x44.



Класс! Теперь мы видим наш аллокация по адресу 0x00481ea8-0x8 (чанк B) была перезаписана атакующей строкой. Также видно, что элемент lookaside содержит значение 0x4444443c. Добавим 0x8, и он превратится в 0x44444444. Именно то, что мы использовали! Теперь вы понимаете, как контролировать flink в чанке B. :)

Как только происходит аллокация чанка такого же размера как и B (0x00481ea8-0x8), он удаляется из lookaside[3] и возвращается вызывающему. Заметьте также, что заголовки также под нашим полным контролем.

Взглянув на чанк A (0x00481e88) мы увидим, что он используется, потому что значение флага равно 0x1 (что говорит о том, что чанк занят). Следующий чанк по адресу 0x00481ea0 пока не обновлён и !!!!![.............]



В этом месте код попытается нарушить доступ операцией READ. При атаке приложения этим методом, мы заменим 0x44444444 указателем на функцию (подделаем flink). Теперь, когда менеджер кучи создаст свежеаллоцированный чанк, приложение будет писать в ту часть памяти, куда указывает поддельный flink. Аллоцируем чанк C и запишем в него произвольный шеллкод. Задача при этом, чтобы наша функция была вызвана до краша приложения (или хотя бы во время краша ;)). В первой части я не упомянул про один классный хак с использованием глобальных указателей PEB (работает только до XP SP1). Однако в SP2 и выше эти указатели теперь рандомизируюся. Давайте откроем бинарник в отладчике:




Повторим:



Заметьте, что два адреса PEB отличатся. При вызове исключения диспетче исключений скорее всего вызовет ExitProcess(), который в свою очередь вызовет RtlAcquirePebLock(), блокируя PEB. Это происходит для того, чтобы не допустить изменения PEB во время исключения. Как только обработчик завершается, блок снимается вызовом RtlReleasePebLock(). К тому же указатели, используемые в этих функциях не имеют защиты W|X (Write, eXecute). Что значит, мы можем писать данные в эту часть памяти и выполнять её содержимое. Каждая из этих функций использует статические указатели на фиксированное смещение в PEB. Ниже показан код RtlAcquirePebLock(). FS:[18] (peb) присваивается EAX. Затем по смещению 0x30 сохраняются указатели на глобальные функции, а по смещению 0x24 - функция FastPebLockRoutine(), которая затем вызывается.


Ниже представлено как RtlReleasePebLock() делает прямой вызов функции FastpebUnlockRoutine(), находящейся по смещению 0x24 в массиве глобальных функций внутри PEB.


Поэтому, когда при исключении вызываются  RtlAcquirePebLock() и RtlReleasePebLock(), ваш код будет вызываться раз за разом до бесконечности. Но вы можете пропатчик PEB при вызове своего шеллкода, заменить указатель так, чтобы он содержал адрес функции exit().



Чем больше текущий процесс содержит тредов (потоков), тем меньше используется рандомизации (рандомизированные адреса используются для нескольких PEB'ов), что даёт возможность "угадать" адреса в текущего PEB. Но это не решает нашу проблем, потому что у нас нет надежного способа записи четвёрки, что бы позволило перезаписать указатель на функцию. Иногда само приложени использует нестандартный указатель либо до исключения, либо как указатель на другую библиотеку Windows. Мы можем переписать его так, чтобы он указывал на наш шеллкод.



Особенности эксплуатации указателей:
Для демонстрации я проведу переполнения чанка в lookaside в Windows XP SP1 (потому что глобальные указатели PEB в ней фиксированы). FastPEBLockRoutine() находится по адресу 0x7ffdf020.

Раскомментируйте эту строку:


И закомментируйте эту:


Теперь мы переполним чанк A строкой из X'ов и перепишем часть чанка B строками AAAA и BBBB и, наконец, перепишем указатель на flink значением 0x7ffdf020. Скомпилируйте программу заново и откройте в отладчике. Аллоцировав чанк C (находящийся по адресу  0x7ffdf020), мы можем записать в него шеллкод, который будет вызван при исключении. Ниже можно увидеть, как в EAX записывается адрес PEB и происходит прямой вызов FastPEBLockRoutine(), что передаёт управление нашему коду.



Имея полный контроль над EIP, его можно использовать для возвращение обратно в код. С этого момента можно с лёгкостью обойти DEP и добиться исполнени кода.


Эксплуатация указателей, определяемая приложением:
Эта статья будет неполной, если я не представлю пример эксплуатации этой уязвимости в Windows XP SP3. При работе с приложениями, содержащими переполнение буфера любой захардкоженый вызов функции, который можно перезаписать и выполнить после переполнения должен быть использован. К примеру WSACleanup() из библиотеки winsock. Он содержит захардкоженный вызов 0x71ab400a в XP SP3. В этом месте мы можем поместить наш шеллкод. Таким образом при вызове WSACleanup() (или других функций winsock), будет вызван наш код. Ниже дизассемлированный код WSACleanup() и поиск захардкоженных вызовов.


Почти любое приложение в Windows скорее всего искольет функции winsock. В частности WSACleanup() используется для очистки любых соединений, что практически гарантирует вызов после переполнения. По этой причине перезапись по адресу 0x71ac4050 работает так устойчиво. Другим примером будет функция recv, которая тоже вызывает эту функцию.


Если послезовать за вызовом 0x71ab678f, мы попадём сюда:

Кто бы мог подумать? Еще один вызов 0x71ac4050. Чтобы удостовериться, что это сработает, взглянем на права доступа.




Фундаментальным недостатком этого метода является то, что при перезаписи кода по этому адресу, любой шеллкод, использующий winsock (я бы сказал, практически все) перестанет работать. Одним из вариантов решения - патчить 0x71ac4050 оригинальным кодом, чтобы вызовы winsock продолжили работать.


Пример эксплуатации указателей, определяемых приложением:

Я предоставил бинарник vulnerserver (большая часть кода взята из блога Стивена Бредшоуса (Stephen Bradshaws) из Infosec Institute, вся слава принадлежит ему) и подправил его так, чтобы он содержал переполнения кучи и утечки памяти.

Идея состоит в том, чтобы написать PoC эксплойт, который при запуске будет выстаивать структуру кучи так, что вы можете переписать чанк в lookaside и получить контроль над выполнением. Скачайте этот файл (b33f: файл недоступен) и запустите его в Windows SP3. Попробуйте примеры, о которых я рассказывал выше, это поможет вам лучше понять, как работает этот метод. Я решил, что пока не буду предоставлять исходник, чтобы люди занялись реверс инжинирингом и сами поняли, как добиться правильной структуры внутри кучи и вызвать свой код. В качестве подсказки (надеюсь не слишком большой) привожу скриншот, на котором PoC определяет структуру кучи:

Разумеется, любая ситуация, в которой вы можете манипулировать со структурой кучи, идеальна. [!!!!...............]
При возможни заскриптовать и контролировать структуру кучи, вы без проблемы будете способны добиться ситуации, которую можно эксплуатировать с помощью переполнения буфера. В качестве примера можно привести heaplib.js Алекса Соритова, которая позволяет аллоцировать и освобождать память и производить множество операций со строками внутри кучи. Если вы используете JavaSctipt или DHTML для аллокации или освобождения чанков в той же куче, что и MSHTML, значит вы можете контролировать менеджер кучи и перенаправлять поток исполнения внутри целевого браузера.