https://www.fuzzysecurity.com/tutorials/mr_me/5.html

Переполнение кучи. Часть 4

Привет, ребята! И снова я здесь, чтобы рассказать вам об очередной важной технике эксплуации кучи, которую я не хотел бы видеть погребённой в песках времени. Мне повезло, и у меня есть немного свободного времени в эти новогодние каникулы, которое я использую, чтобы рассказать о ней. Для начала освежим в памяти уже пройдённые материалы:

Переполнение кучи. Часть 1:
	Основый эксплуатации unlink() и перезаписи указателей на функции
	Эксплуатация фильтра необработанных исключений (UEF)
	Эксплуатация векторной обработки прерываний (VEH)

Переполнение кучи. Часть 2:
	Рассмотрены еще несколько структур кучи и используемых ею алгоритмов аллокации и освобождения памяти, таких как: RtlAllocateHeap() RtlFreeHeap(), слияние, разделение блоков. Такие структуры как: кучи, сегменты, списки lookaside и freelist, заголовки чанков и тд.
	Безопасный unlink
	Куки заголовков кучи
	Техника эксплуатации: перезапись чанка в списке lookaside aka "перезапись ListHead"

Переполнение кучи. Часть 3:
	Описана еще одна популярная атака вставки в freelist[0]
	Описан плагин для ImmunityDebugger !heaper

Переполнение кучи. Часть 4 (этот туториал):
	Теория битмапа FreeListInUse
	Описана атака Николаса Вайзмана (Nicolas Wiseman) "инаверсия битмапа FreeListInUse"
	Объясняю, как я облажался с RtlCommitRoutine :/ и как это, возможно, можно исправить
	Heaper получает возможность анализа битмапа FreeListInUse. Для удобной работы с кодом создан репозиторий на GitHub


Ну что ж начнём! Хватайте 0xc0ff3333 и приготовьтесь усердно думать!

FreeListInUse

FreeListInUse - это структура размером 16 байт, расположенная по смещению 0x0158 относительно начала кучи. Она содержит размер таблицы, состоящей из элементов FreeList[n] с пустыми чанками. Задачей битовой маски FreeListInUse является ускорение RtlAllocateHeap() при аллокации из FreeList. В процессе аллокации менеджер кучи будет сканировать битмап (доступные ячейки памяти) в зависимости от запрощенного размера, добавляя 8 и деля сумму на 8. Например, мы хоти аллоцировать 664 байта. Прибавим к нему 8 (674) [?!?!?!?!?] и, разделив на 8, получим 84 (0x54). Далее менеджер начнёт сканирование с FreeList[0x54] и далее. Эта оптимизация нацелена просто на ускорение работы менеджера кучи.

Взглянем как выглядит битмап:


Так, 4 лонга, по 32 бита каждый, в целом составляют 128 (в точности размер FreeList). Но рассматривать его в таком виде сложно. Посмотрим поближе:

Если вы аллоцируете из элемента FreeList[n] и при этом выбран последний чанк, бит будет сброшен. Точно так же, если используется HeapFree() и чанк освобождается во FreeList (предположим, что lookaside заполнен), бит будет установлен. В функции ntdll!RtlAllocateHeap происходит XOR текущего значения с единицей, возвращая новое значение:

Важно отметить, что byteToSet всегда будет равен единице. Проведём пару тестов XOR.

Мы видим что значение FreeListInUse зависит от последнего значения. Остановитель и задумайтесь прежде, чем продолжить. Мы эксплуатируем этот простой факт и принцип работы фукнции XOR. Что если нам удастся добиться ситуации, в которой мы будет контролировать один бит в FreeListInUse?

Эксплуатаци FreeListInUse (bitmap flip attack, атака инверсией битмапа)

Прежде чем демонстрировать способы инверсии битов во FreeListInUse, давайте рассмотрим результаты подобной ситации. Допустим, у вас есть 0 доступных чанков в элементе FreeList[0x66]. Это будет выглядеть вот так:

В сущности FreeListInUse для этого элемента будет содержать 0. Теперь предположим, что FreeListInUse был установлен в 1. Запроси мы аллокацию определённого размера (0x66*0x8/8) или меньше, RtlAllocateHeap() начнёт сканировать FreeListInUse и искать элемент, удовлетворяющий запросу (при условии, что lookaside пуст).

Так на запрос вернётся адрес 0x00a804a8 как "валидный" чанк. Теперь поскольку при отсутствии чанков FreeList[n] указывает только на самого себя, будет возвращаться смещение, близкое к структурам управления текущей кучей.

Несложно понять, что на этом этапе будет просто записать по адресу 0x00a804a8, скажем, 216 байт и перезаписать указатель RtlCommitRoutine, расположенный по смещению 0x57c. Однако в процессе тестирования этой атаки и восстановления RtlAllocateHeap(), я заметил, что должно выполняться еще одно условие после инверсии FreeListInUse.

Обратите внимание на инструкцию TEST CL,0x10. Мы знаем, что 0x10 обозначает последний чанк в элементе. Теперь если мы заглянем во FreeList[n], адрес чанка будет указывать на flink/blink, но не на заголовок. Для проверки этого условия нам нужно взять адрес чанка, отнять от него 0x8 и прибавить 0x5, чтобы добраться до флага чанка в его заголовке. Это проще понять визуально:

Если мы сдампим чанк по адресу 0x00a804a8, тогда его заголовок будет расположен в 0x00a804a0, а флаг - в 0x00a804a5 (курсор установлен на нём):

Если мы изменим его на известное значение (0x10 вместо 0x04) и инструкция TEST будет исполняться с аргументом 0x10, проверка не будет пройдена и прыжок не будет производиться (конечно, CMP был бы лучшим вариантом). Псевдокод выглядит примерно так:

if (chunk->flag & 0x10) <= 0:
           walk_freelist_entry()

Давайте изменим его:

Какие бы значения мы бы не использовали, бит номер 5 в их бинарном представлении должен быть установлен, чтобы пройти проверку (то есть, 0b00010000). Получается мы имеем 256 / 2 = 128 возможных байтов, которые можно использовать для прохождения проверки на ПОСЛЕДНИЙ чанк. Вот эти значения:

0x10-0x1f
0x30-0x3f
0x50-0x5f
0x70-0x7f
0x90-0x9f
0xb0-0xbf
0xd0-0xdf
0xf0-0xff

Как уже было сказано ранее Freelist начинается с 0x0178 и заканчивается на 0x0570. Получается, можно использовать только значения 0x01-0x5, что не сработает для чанка, расположенного во  freelist[n]. Одним из вариантов обойти это будет иметь свободный чанк в FreeList[n] ПЕРЕД тем чанком, который вы хотите аллоцировать. Его адресс должен содержать байт из списка выше на третьей слева позиции. Например, 0xXXXXYYXX, где YY - один из перечисленных выше байтов. Еще раз изобразим это:



Видно, что предыдущий элемент содержит значение 0x32 вместо 0x4. Посмотрим дамп:

Обойдёт ли 0x32 проверку? Да, проверка на условие вернёт False и переход не произойдёт:

>>> print (0x32 & 0x10) <= 0
False

Раз уж переход не происходит, начнём разрывать связи. Допустим мы делаем вызов HeapAlloc(984). На данном этапе в регистре EAX нам должен вернуться адрес 0x00490558.

Инверсия бита

Прежде чем мы аллоцируем из FreeList[n] подделанный чанк, нам придётся как-то обойти битовую маску. Пока что мне известны три способа:

Добиться переполнения буфера кучи и изменить размер только чанка из FreeList[n] (он должен быть единственным чанков в элементе). Заменять размер нужно в соответствии с позицией бита, который вы хотите перевернуть. Так при освобождении изменённого чанка будет меняться бит соответсвующего размера.

Добиться переполнения кучи, изменить размер чанка, flink/blink и выставить флаг чанка в значение 0x10. Этот чанк должен храниться во FreeList[n], но не обязан быть единтвенным. Присвоив flink и blink одно и то же значение и установив флаг, мы добиваемся того, что система думает, что это последний чанк в элементе Freelist. При аллокации этого чанка бит во FreeListInUse, соответсвующий его размеру станет равер единице.

Получить контроль над [примитивами] через "inc(ptr)". Изменить значение FreeListInUse для пустого элемента. Аллоцировать чанк размером "(размер элемента) - 8". Кто сказал, что не понадобится переполнение буфера? Об этом ниже.

В процессе тестирования и анализа результатов я понял, насколько важно иметь возможность симулировать переключение битов FreeListInUse. Поэтому я добавил в !heaper функцию, которая даст вам возможность это делать.

Взглянем на FreeListInUse из кучи 0x00490000:

Изменим элемент FreeList[20] во FreeListInUse:

Теперь всё что нам нужно это убедиться, что свободный чанк находится в FreeList[0x1c] и соответствующий ему флаг имеет установленный 5й бит (см. выше).

30 мая 2007 года Николас Вайсман отправил в список рассылки DailyDaves загадку про то, как аналитики безопасности могли бы эксплуатировать инструкции inc [r32], имея контроль над [примитивами].

Давайте-ка для поддержания духа	решим интересную загадку (чуваки, сейчас 11 часов вечера, а впереди бессонная ночь).

Загадка: допустим вы хотите заэксплоитить удалённый сервис на старенькой Windows 2000 (любой SP) и имеете примитив inc [edi] (вы контролируете edi).

Что лучше всего поместить в edi?

Нико

Если бы мы могли получить контроль на примитивом и могли бы инкрементировать указатель на любой участок памяти несколько раз, мы могли бы провести такую атаку:

Предположим следующее (так себе предположение, я знаю):

База кучи расположена на 0x00490000
Во FreeList[n] нет элементов, кроме FreeList[0]
Значение EDX контролируется нами
Мы находимся на инструкции: inc byte [edx]

Мы можем произодить инкремент несколько раз (вы скорее всего могли бы провести и другие атаки, но этот пример задумат именно так)


1) Кладём в EDX 0x0049015c и изменяем FreeListInUse.

Взглянем на FreeListInUse:

2) Теперь нужно убедиться, что флаг чанка во FreeList[0x20], указывающего на сам элемент (поддельный чанк), установлен в нужное значение. Текущее его значение:

Это было просто, теперь инкрементируем его до 0x10, используя контролируемый нами примитив:

Теперь, при запросе на аллокацию 0x20 байт менеджер кучи радостно вернет указатель на FreeList[20] (0x00490278)! 

Нам даже не понадобилось переполнение кучи! :)
Мы не освобождали чанки из FreeList[n]!
Нужно было контролировать примитив для инструкции inc byte [r32].
Нужно было контролировать две аллокации определённого размера. Одна достаёт элемента FreeList[n] в виде валидного чанка и другая - запрашивает у аллокатора выделение дополнительной памяти, обращающееся к указателю на функцию RtlCommitRoutine().

Эксплуатация через RtlCommitRoutine

Мне не удалось добиться успешного использования этой эксплуатации (по крайней мере сейчас). Это связано с большим количеством [сломанных] указателей в структуре кучи, которые каким-то образом использовались (чтение/запись) до обращения к RtlCommitRoutine по смещению 0x57c. Среди них указатель на Lock Variable по смещению 0x578.

Так или иначе вот код, который я пытаюсь использовать:

Однако если у вас уже есть возможность "записи четвёрки" или вы можете перезаписать flink чанка из lookaside и вернуть его, вы можете просто перезаписать сам указатель. heapbase+0x57c->heapbase+0x608->RtlCommitRoutime. Предполагая, что база кучи находится на 0x00490000, нужно будет просто присвоить flink 0x0049608 и поместить туда произвольный код.

Где же я облажался?

Для начала нам нужно пройти две проверки, начиная с 0x7c90100b.

Их можно пройти, поместив по смещению lock variable значение 0xffffffff00000000 в структуре кучи (это можно сделать через переполнение). Затем проверяется, есть ли свободные чанки во FreeList[0].

После этого мы попадаем в код, проверяющий смещение 0x668 (я думаю, что это указатель на FrontEndHeapType) и 0x654 на равенство определённым значениям. Но я подозреваю, что эти смещения некорректны, потому что значение EAX вероятно было неправильным 0x00490640.

Как только проверки пройдены, вызывается sub_7C918AE3.