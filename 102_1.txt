https://www.fuzzysecurity.com/tutorials/mr_me/3.html

Переполнение буфера кучи для людей. Часть 2

В первой части я рассказывал про способы эксплуатации переполнения буфера кучи на старой версии Windows. Задачей было предоставить читателю практические знания и понимание того, как работает процесс выделения/освобождения памяти и как через указатели flink/blink из freelist[n] можно записывать произвольные 4 байта.

В этой статье я в первую очередь освежаю свои собственные знания (я забывчив), а также пытаюсь помочь специалистам по безопасности обрести понимание принципов работы менеджера кучи в старых версиях Windows (NT v5 и старше). Это нужно для эксплуатации переполнения кучи и преодоления некоторых ограничений, необходимых для предлотвращения "записи четырёх байт". В дополнение это даст читателю некоторую точку отсчёта в знаних, которая без сомнения пригодится при атаке более свежих версии кучи windows.

Этот туториал расскажет только обо одной хорошо известной методике обхода системы защиты кучи в Windows XP SP2/SP3. Таким образом он ни в коей мере не является полным руководством или попыткой описать все детали кучи.

Для продолжения потребуется относительно глубокое понимание работы структур кучи в windows XP/Server 2003. Для этой статьи и на основе фидбека о первой части "Переполнения буфера кучи для людей", я расскажу некоторые элементы внутренней работы кучи.

Если вы не знакомы с принципами переполнения буфера кучи, я рекомендую вам сперва сфокусироваться на этой теме.

Чтобы повторить мои действия вам понадобится:

– Windows XP с установленным SP1
– Windows XP с установленным SP2/SP3
– Отладчик (Olly Debugger, Immunity Debugger, windbg и т.д.)

– Компилятор C/C++ (Dev C++, lcc-32, MS visual C++ 6.0 (если вы сможете его достать)).

– Удобный для вас скриптовый язык (Я использую python, вы можете пользоваться perl)

– Мозги (и/или настойчивость)

– Некоторые знания Ассемблера, C. Также умение использовать плагин HideDbg для Olly или !hidedebug в Immunity debugger

– Время.

Налейте себе кофе, и вперёд изучать таинственное тёмное искусство.

Так что же такое чанк и блок?

Windows имеет специальную структуру, которая называется куча. По смещению 0x90 в структуре PEB(Process Environment Block) находится список куч данного процесса в хронологическом порядке. Давайте взглянем на них:

Используя Windbg, мы найдём текущий PEB с помощью команды !peb. Эту же команду можно использовать в Immunity Debugger. Очень простой код, возвращающий адре PEB приведён ниже:

##########################
##########################
##########################

Давайте сдампим двоичные слова, находящиеся по этому указателю:

##########################
##########################
##########################

Адреса, выделенные жирным - это кучи, используемые текущим процессом. Эти же данные можно получить в обоих отладчиках командой !heap.

Также в windbg вы можете просмотреть статистику по каждой куче командой !head -stat. Ниже её вывод:

##########################
##########################
##########################

Наконец, в Immunity Debugger можно сдампить метаданные кучи, используя флаги -h или -q.

##########################
##########################
##########################

Первая куча (0x00240000) - стандартная. Остальные создаются компонентами C или конструкторами. Последняя куча в списке (0x00480000) создана нашим приложением.

Приложение может использовать функцию HeapCreate() для создания дополнительно кучи(куч) и храненить указатели на них по смещению 0x90 в PEB. Ниже представлено объявление HeapCreate() в Windows API.

Вызов HeapCreate() с корректными параметрами возвращает указатель на созданную кучу, который хранится в регистре EAX.

Описание аргументов:

flOptions
        + HEAP_CREATE_ENABLE_EXECUTE: разрешить исполнение кода
        + HEAP_GENERATE_EXCEPTIONS: если вызов HeapAlloc() или HeapReAlloc() не может быть корректно отработан, вызывается исключение
        + HEAP_NO_SERIALIZE: не использовать сериализованный доступ при работе функций с кучей

dwInitialSize
		+ исходный размер памяти выделяемый для кучи, округлённый до ближайшей границы страницы (4Кб). Если равен 0, выделяется куча размером в одну страницу. Должно быть меньше dwMaximumSize

dwMaximumSize
		+ максимальный размер кучи. Если вызов HeapAlloc() или HeapReAlloc() превышает dwinitialSize, менеджер виртуальной памяти вернёт нужное количество страниц, остальные будут храниться в freelist. Если dwMaximumSize равен нулю, куча будет расти. Ограничена она будет только величиной доступной памяти.

Больше информации о флагах можно найти на MSDN. Ниже показана таблица, содержащая структуру кучи с подсвеченными важными элементами. Чтобы увидеть её в windbg, используйте команду "dt _heap"